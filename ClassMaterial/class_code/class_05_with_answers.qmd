---
title: "Class 5 notes and code"
format: pdf
editor: source
editor_options: 
  chunk_output_type: console
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```





$\\$




# Downloading data files 

Please run the code below to download the data we will use today. 


```{r download_files, echo = FALSE, eval = FALSE}

# you could also try downloading these files using the SDS111 package
library(SDS111)


download_data("movies.Rdata")

download_image("new_pipe.png")


```





$\\$






## Part 1: Data wrangling with dplyr 


We can use the package dplyr to wrangle data. dplyr is part of the 'tidyverse'
which is a collection of packages that operate on data frames.

The main functions in dplyr we will use are:

 * `filter()`
 * `select()`
 * `mutate()`
 * `arrange()`
 * `group_by()`
 * `summarize()`


Let's explore how these functions work!






$\\$






### Part 1.1: Loading and viewing movie data



To explore the dplyr functions, we will use data that consists of random sample
of movies that were scraped from the [Rotten
Tomatoes](https://www.rottentomatoes.com/) and [IMDB](https://www.imdb.com/)
websites. A code book describing the variables in this data frame and be found
on [this website](http://www2.stat.duke.edu/~mc301/data/movies.html).


Below is code that loads the data. You can use the `View()` function from the
console to look at the data. The `glimpse()` function in dplyr is also useful
for getting a sense of what is in a data frame.


How many cases and variables are in this data frame? 



```{r load_movies}


# loading the dplyr library 
library(dplyr)


# load the data
load("movies.Rdata")


# can only be run from the console
# View(movies)


# the dplyr glimpse() function gives a quick view of a data frame
glimpse(movies)


# the number of rows and columns in the data frame
dim(movies)


```






$\\$







### Part 1.2: Filtering for only specific rows 



To look at a more homogeneous data set, let's reduce our data to only feature
films. To get this subset of the data we can use dplyr's `filter()` function. We
will filter variable `title_type` to only have the value of "Feature Film".


```{r filter}


# let's get only the feature films
films <- filter(movies, title_type == "Feature Film")


# let's look at the number of cases and variables in the films data frame
dim(films)


```






$\\$







### Part 1.3: Selecting only key variables

The data films data frame contains several variables we are less interesting in.
We can reduce a data frame to just variables we are interested in using the
`select()` function. Let's select the following variables from the data frame:

1. `title`
2. `genre`
3. `runtime`
4. `mpaa_rating`
5. `critics_score`
6. `audience_score`



```{r select_vars}


# select the relevant variables
films_2 <- select(films, 
                title, genre, runtime, mpaa_rating, critics_score, audience_score)
                
                

# look at the data frame size
dim(films_2)

```





$\\$





### Part 1.4: Adding new variables with mutate()

We can add new a variable to a data frame that is combinations of variables that
already exist in the data frame using the `mutate()` function.

Let's add a variable that is the difference between the audience_score and the
critics_score which will tell us which movies the audience enjoyed more than
critics did.



```{r mutate}


# create a new variable that is the difference between the audience_score and the critics_score
films_3 <- mutate(films_2, audience_prefers = audience_score - critics_score)


dim(films_3)


head(films_3)



```





$\\$





### Part 1.5: Sorting data frames with arrange()

We can arrange the rows in a data frame based on the values in a variable using the `arrange()` function. 

Let's arrange the data in order from lowest to highest values based on the difference between the audience and critic scores.

We can also arrange data from highest to lowest using the `desc()` function. 



```{r arrange}


# arrange the data from lowest to highest values of the audience preference
films_4 <- arrange(films_3, audience_prefers)

# arrange the data from highest values to the lowest values of the audience preference
films_4 <- arrange(films_3, desc(audience_prefers))


dim(films_4)


head(films_4)



```




$\\$






### Part 1.6: Summarizing data using the summarize() function

Let's examine if critics scores are higher than audience scores on average? 



```{r summarize}


summarize(films_3, mean_critic = mean(critics_score), mean_audience = mean(audience_score))


```





$\\$






### Part 1.7: Grouping data with group_by()

We can group data by the values in a particular (usually categorical) variable
using the `group_by()` method. This method does nothing on it's own, but is
useful in conjunction with other dplyr functions, particularly the `summarize()`
and `mutate()` functions.

Let's summarize how much more audiences liked movies relative to critics
separately for each genre of movie.


```{r group_by}

films_5 <- group_by(films_3, genre) 

summarize(films_5, mean_critic = mean(critics_score), mean_audience = mean(audience_score))

```



$\\$





### Part 1.8: The pipe operator


The pipe operator (|>) allows us to string together a series of commands. It
allows us to place the first argument of a function outside the function. Since
all dplyr functions take a data frame as their first argument, and return a data
frame as their output, this allows us to string together a chain of dplyr
functions (like a grammar).


Let's redo all our above analyses using the pipe operator. 



```{r pipe}


# filter for only feature films using the pipe operator

films <- filter(movies, title_type == "Feature Film")

films_pipe <- movies |>
  filter(title_type == "Feature Film")

identical(films, films_pipe)




# putting everything together

film_results <- movies |>
  filter(title_type == "Feature Film") |> 
  select(title, genre, runtime, mpaa_rating, critics_score, audience_score) |>
  mutate(audience_prefers = audience_score - critics_score) |>
  group_by(genre) |>
  summarize(mean_audience_prefers = mean(audience_prefers)) |>
  arrange(desc(mean_audience_prefers))
    

film_results


```




$\\$





### Part 1.9: Practice


You now have learned a powerful set of tools to transform data in order to extract insights.


Please explore the data further using the dplyr functions to see if you can find additional interesting trends! 




![](new_pipe.png)




## Part 2: Visualizations with ggplot


We can use the ggplot2 package, which is part of the tidyverse, to create much
nicer looking graphics than using base R graphics. The ggplot2 library is
modeled on Leland Wilkinson's "grammar of graphics" which creatse
graphics from a combination of basic visual elements.

In the exercises below, we will learn how to use ggplot using the motor trends
cars data set (mtcars) that comes with base R installation, and also the
gapminder data.

A few resources to learn more about ggplot are: 

- [R for Data Science](https://r4ds.hadley.nz/)
- [The ggplot cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)


$\\$





### Part 2.1: Scatter plots


Let's create plots of the number of miles per gallon (mpg) cars get as a
function of the weight of the car.


```{r scatter_plot}


# install.packages("ggplot2")


library(ggplot2)


# base R
plot(mtcars$wt, mtcars$mpg)


# ggplot - global mapping
ggplot(data = mtcars, mapping = aes(x = wt, y = mpg)) +
	geom_point() 


# ggplot - shorter global mapping
ggplot(mtcars, aes(x = wt, y = mpg)) +
	geom_point() 


# ggplot - mapping in the geom
ggplot(data = mtcars) +   
	geom_point(mapping = aes(x = wt, y = mpg))


```




$\\$





### Part 2.2: Adding labels to plots


We can add labels to the plots using the `labs()` function. Arguments to `labs()` function include:
- `x`: the label on the x-axis (you can also use the `xlab()` function)
- `y`: the label on the y-axis (you can also use the `ylab()` function)
- `title`: the title of the plot  (you can also use the `ggtitle()` function)
- `subtitle`: the title of the plot  (you can also use the `ggtitle()` function)

If you just want to add x and y labels or a title, you can also use the `xlab("label1")`, `ylab("label2")` and/or the `ggtitle()` functions. 



```{r labels}


ggplot(mtcars, aes(x = wt, y = mpg)) +  	  	
	geom_point()  +    
	labs(x = "Weight",
	     y = "Miles per Gallon",
	     title = "MPG as a function of weight", 
	     subtitle = "ggplot is cool!")



# another way to add just x and y labels
ggplot(mtcars, aes(x = wt, y = mpg)) +  	  	
	geom_point()  +    
	xlab("Weight") +   
	ylab("Miles per Gallon") + 
  ggtitle("MPG as a function of weight")


```



Remember, if you don't want exes [label your axes](https://xkcd.com/833/)






$\\$





### Part 2.3: More aesthetic mappings


We can use other aesthetic mappings beyond position including:
- `color`: different color scales are used for quantitative and categorical (factor) data 
- `shape`: should be categorical data
- `size`: should be quantitative data



```{r mappings}


# add color based on the transmission type (is automatic or not)
ggplot(mtcars, aes(x = wt, y = mpg, color = am)) +
	geom_point()


# it is better to treat the transmission type as a categorical variable?
ggplot(mtcars, aes(x = wt, y = mpg, col = factor(am))) +  
  geom_point()


# can also try mapping transmission type to shape or size 
ggplot(mtcars, aes(x = wt, y = mpg, shape = factor(am))) +  
   geom_point()
 
ggplot(mtcars, aes(x = wt, y = mpg, size = am)) +  
   geom_point()


```



Question: When adding the variable automatic/manual transmission (am) to the
scatter plot mpg vs. weight, do you think it is best to map am on to...?

a. color
b. shape
c. size




$\\$





### Part 2.4: Attributes vs. Aesthetics


Setting an **aesthetic mapping** maps a variable to a **glyph property**. This
is done **inside** the `aes()` function.

Setting an **attribute** set a glyph property to a **fixed value**. This is done
**outside** the `aes()` function.



```{r aesthetics_vs_attributes}


# setting an aesthetic mapping
ggplot(mtcars) +
	geom_point(aes(x = wt, y = mpg, col = factor(am)))


# setting an attribute
ggplot(mtcars) + 
	geom_point(aes(x = wt, y = mpg), col = "red")


```




$\\$





### Part 2.5: Facets


Beyond comparing variables based on aesthetic mappings, you can compare
categorical variables by splitting a plot into subplots, called facets, using
`facet_wrap()`


```{r facets}


# separate subplots for the two transmission types
ggplot(mtcars, aes(x = wt, y = mpg)) +  	
  geom_point() +   
	facet_wrap(~am)


# One can also do facets in two dimensions
ggplot(mtcars, aes(x = wt, y = mpg)) +  	
	geom_point() +   
	facet_wrap(am ~ cyl)



```




$\\$






### Part 2.6: geoms


We can use different geoms to create other types of plots.



```{r geoms1}

library(gapminder)


# Let's create a plot that shows the GDP in the United States as a function of the year using the geom geom_line()
gapminder |> 
  filter(country == 'United States') |>  	
  ggplot(aes(x = year, y = gdpPercap)) + 	  
	geom_line()


# Let's create a plot that shows the GDP in the United States as a function of the year using the geom geom_col()
gapminder |> 
  filter(country == 'United States') |>  	
  ggplot(aes(x = year, y = gdpPercap)) + 	  
	geom_col()


# Let's MPG as a function of weight using the names of cars rather than just points for each car
mtcars |>
  tibble::rownames_to_column() |>
  ggplot(aes(x = wt, y = mpg)) + 
	geom_text(aes(label = rowname))


# Let's plot a histogram of the weights of cars
ggplot(mtcars, aes(x = wt)) + 	  	
	geom_histogram(bins = 10)


# Let's create a boxplot of the weights of cars
ggplot(mtcars, aes(x = "", y = wt)) + 	  	
	geom_boxplot()


# Let's create a side-by-side boxplot of the weights of cars depending on the number of cylinders the engine has
ggplot(mtcars, aes(x = factor(cyl), y = wt)) + 	  	
  geom_boxplot()



```





$\\$





### Part 2.7: geoms continued

Violin and Joy plots are other ways to view distributions of data



```{r geoms2}

# violin plot 
ggplot(mtcars, aes(x = factor(cyl), y = wt)) + 	
	geom_violin()



library("ggridges")

# joy plot
ggplot(mtcars, aes(y = factor(cyl), x = wt)) + 	
  geom_density_ridges()



```


Question: Can you figure out where the name "joy plot" comes from? 





$\\$






### Part 2.8: Multiple layers


We can also have multiple geom layers on a single graph by using the + symbol
E.g   `ggplot(…) + geom_type1() + geom_type2()`



```{r geoms3}


# Create a scatter plot of miles per gallon as a function of weight and then add a smoothed line using geom_smooth() and a vertical lines using geom_vline()

ggplot(mtcars, aes(x = wt, y = mpg)) +  	
	geom_point() +  
	geom_smooth() +
  geom_vline(xintercept = 3)


```





$\\$





### Part 2.9: Themes


We can also use different themes to change the appearance of our plot.


```{r themes}


# Add theme_classic() to our plot

ggplot(mtcars, aes(x = wt, y = mpg)) +  	  	
	geom_point()  +    
	xlab("Weight") +   
	ylab("Miles per Gallon") + 
	theme_classic() + 
  theme(                                              # modify the theme by:
        axis.text.y = element_blank(),                #  - turning off the y-axis text
        plot.background = element_rect(fill = "red")  # - making the background red
        )                                             # see ? theme for more options


# install.packages("ggthemes")
library(ggthemes)

ggplot(mtcars, aes(x = wt, y = mpg)) +  	  	
	geom_point()  +    
	ggtitle("Cars!") + 
	theme_fivethirtyeight()

```




$\\$




### Part 2.10: Overplotting


Sometimes points overlap making it hard to estimate the number of points at a
particular range of values.

We can control the transparency of points by changing their alpha values.



```{r transparency}

library(gapminder)


# a lot of overplotting
ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + 	
	geom_point()


# changing the transparency levels makes it a bit easier to see how many points are at a given x, y location
ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + 	
	geom_point(alpha = .1)



```





$\\$





### Part 2.11: Changing scales


Each visual attribute that has an aesthetic mapping has a default scales. We can
change the scales used for each mapping using functions that start with
`scale_`.

For example, we can change the x-scale from liner to logarithmic using
`scale_x_continuous(trans='log10')`. Likewise we can change the color scale
using `scale_color_manual()`.



```{r scales}

# changing the scale on the x-axis
ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + 	
	geom_point(alpha = .2) + 
  scale_x_continuous(trans='log10')


# mapping continents to colors, and adding my own color scale
ggplot(gapminder, aes(x = gdpPercap, y = lifeExp, col = continent)) + 	
	geom_point(alpha = .2) + 
  scale_x_continuous(trans='log10') + 
  scale_color_manual(values = c("red", "yellow", "green", "blue", "purple"))


```





$\\$





### Part 2.12: Adding annotations to plots

We can add annotations to plots using the `annotate("text", x = , y = , label = )` function.



```{r annotations}


ggplot(mtcars, aes(x = wt, y = mpg)) +  	  	
	geom_point()  +    
	annotate("text", x = 4, y = 30, label = "AWESOME!")


```





$\\$




### Part 2.13: Exeriment yourself


Try to create some interesting visualizations from either a data set we have used in the class, or a new data set you found.




```{r experiment}










```






$\\$




